# -*- coding: utf-8 -*-
"""data_pipeline.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15WLB_jAPvkBiKqkGDbtSi65D0iA4G_1_
"""

import pandas as pd
print("Pandas loaded successfully!")

# Load orders.csv file
orders = pd.read_csv('orders.csv')
print("CSV file loaded!")
print("First 5 rows of orders:")
print(orders.head())

from google.colab import files
uploaded = files.upload()

import os
print(os.listdir())

print("Columns in orders:")
print(orders.columns.tolist())

# See sample data
print("\nSample data:")
print(orders.head())

# Load JSON file
import json

with open('users.json') as f:
    users_data = json.load(f)

# Convert to pandas
users = pd.DataFrame(users_data)
print("JSON file loaded!")
print("\nColumns in users:")
print(users.columns.tolist())
print("\nSample data:")
print(users.head())

with open('restaurants.sql', 'r') as f:
    sql_content = f.read()

print("First 500 characters of SQL file:")
print(sql_content[:500])

import sqlite3

# Create a temporary database in memory
conn = sqlite3.connect(':memory:')
cursor = conn.cursor()

# Read the entire SQL file
with open('restaurants.sql', 'r') as f:
    sql_script = f.read()

# Execute all SQL commands
cursor.executescript(sql_script)

# Load into pandas
restaurants = pd.read_sql_query("SELECT * FROM restaurants", conn)
conn.close()

print("SQL file loaded!")
print("\nColumns in restaurants:")
print(restaurants.columns.tolist())
print("\nSample data:")
print(restaurants.head())

# Merge orders with users
merged_step1 = pd.merge(orders, users, on='user_id', how='left')
print("Step 1: Orders + Users merged")
print("Shape before:", orders.shape)
print("Shape after:", merged_step1.shape)
print("\nSample merged data:")
print(merged_step1.head())

# Merge with restaurants
final_data = pd.merge(merged_step1, restaurants, on='restaurant_id', how='left')
print("Step 2: Added restaurants")
print("Final shape:", final_data.shape)
print("\nFinal data sample:")
print(final_data.head())

# Save to CSV file
final_data.to_csv('final_food_delivery_dataset.csv', index=False)
print("✅ SUCCESS! File saved as: final_food_delivery_dataset.csv")
print("Check the files section (left sidebar) to see it!")

# ============================================
# HACKATHON QUESTIONS ANALYSIS BY SHREEKANTH
# ============================================

import pandas as pd
import numpy as np
from datetime import datetime

# Loading final merged dataset
df = pd.read_csv('final_food_delivery_dataset.csv')

# Converting date column
if 'order_date' in df.columns:
    df['order_date'] = pd.to_datetime(df['order_date'], format='%d-%m-%Y')
    df['order_quarter'] = df['order_date'].dt.quarter

# Ensuring numeric columns
numeric_cols = ['total_amount', 'rating']
for col in numeric_cols:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='coerce')

print("=" * 60)
print("MULTIPLE CHOICE ANSWERS BY SHREEKANTH")
print("=" * 60)

# Q1: Which city has the highest total revenue from Gold members?
gold_df = df[df['membership'] == 'Gold']
city_gold_rev = gold_df.groupby('city')['total_amount'].sum()
q1_answer = city_gold_rev.idxmax()
print(f"1. {q1_answer}")

# Q2: Which cuisine has the highest average order value?
cuisine_avg = df.groupby('cuisine')['total_amount'].mean()
q2_answer = cuisine_avg.idxmax()
print(f"2. {q2_answer}")

# Q3: How many distinct users placed orders worth > ₹1000 total?
user_total = df.groupby('user_id')['total_amount'].sum()
high_value_users = user_total[user_total > 1000]
q3_count = len(high_value_users)

# Determine range
if q3_count < 500:
    q3_answer = "< 500"
elif 500 <= q3_count <= 1000:
    q3_answer = "500 – 1000"
elif 1001 <= q3_count <= 2000:
    q3_answer = "1000 – 2000"
else:
    q3_answer = "> 2000"
print(f"3. {q3_answer}")

# Q4: Which restaurant rating range generated highest total revenue?
# Create rating ranges
df['rating_range'] = pd.cut(df['rating'],
                           bins=[3.0, 3.5, 4.0, 4.5, 5.0],
                           labels=['3.0 – 3.5', '3.6 – 4.0', '4.1 – 4.5', '4.6 – 5.0'])
rating_rev = df.groupby('rating_range')['total_amount'].sum()
q4_answer = rating_rev.idxmax()
print(f"4. {q4_answer}")

# Q5: Among Gold members, which city has highest average order value?
city_gold_avg = gold_df.groupby('city')['total_amount'].mean()
q5_answer = city_gold_avg.idxmax()
print(f"5. {q5_answer}")

# Q6: Which cuisine has lowest distinct restaurants but significant revenue?
cuisine_stats = df.groupby('cuisine').agg({
    'restaurant_id': 'nunique',
    'total_amount': 'sum'
})
# Find cuisine with low restaurant count but high revenue
cuisine_stats = cuisine_stats.sort_values('restaurant_id')
# Typically, the one with fewest restaurants but decent revenue is Italian
# We'll compute it:
cuisine_stats['revenue_per_restaurant'] = cuisine_stats['total_amount'] / cuisine_stats['restaurant_id']
# Look for cuisine with low restaurant count but high revenue per restaurant
# Sort by restaurant count ascending, then by revenue per restaurant descending
cuisine_sorted = cuisine_stats.sort_values(['restaurant_id', 'revenue_per_restaurant'],
                                           ascending=[True, False])
q6_answer = cuisine_sorted.index[0]
print(f"6. {q6_answer}")

# Q7: Percentage of total orders by Gold members
total_orders = len(df)
gold_orders = len(gold_df)
gold_percentage = round((gold_orders / total_orders) * 100)

# Find closest option
options = [40, 45, 50, 55]
q7_answer = min(options, key=lambda x: abs(x - gold_percentage))
print(f"7. {q7_answer}%")

# Q8: Restaurant with highest AOV but <20 orders
restaurant_stats = df.groupby('restaurant_name_y').agg({
    'total_amount': ['count', 'mean']
})
restaurant_stats.columns = ['order_count', 'avg_order_value']
low_volume = restaurant_stats[restaurant_stats['order_count'] < 20]
if not low_volume.empty:
    q8_restaurant = low_volume.sort_values('avg_order_value', ascending=False).index[0]
else:
    # If none have <20 orders, find the one with minimum orders
    q8_restaurant = restaurant_stats.sort_values(['order_count', 'avg_order_value'],
                                                 ascending=[True, False]).index[0]
print(f"8. {q8_restaurant}")

# Q9: Which combination contributes highest revenue?
combo_revenue = df.groupby(['membership', 'cuisine'])['total_amount'].sum()
top_combo = combo_revenue.idxmax()
q9_answer = f"{top_combo[0]} + {top_combo[1]}"
print(f"9. {q9_answer}")

# Q10: Quarter with highest total revenue
if 'order_quarter' in df.columns:
    quarter_rev = df.groupby('order_quarter')['total_amount'].sum()
    q10_quarter = quarter_rev.idxmax()
    quarter_map = {1: 'Q1 (Jan–Mar)', 2: 'Q2 (Apr–Jun)',
                   3: 'Q3 (Jul–Sep)', 4: 'Q4 (Oct–Dec)'}
    q10_answer = quarter_map.get(q10_quarter, f"Q{q10_quarter}")
    print(f"10. {q10_answer}")

print("\n" + "=" * 60)
print("NUMERICAL ANSWERS BY SHREEKANTH")
print("=" * 60)

# N1: Total orders by Gold members
n1_answer = len(gold_df)
print(f"N1. {n1_answer}")

# N2: Total revenue from Hyderabad (rounded)
if 'city' in df.columns:
    hyderabad_rev = df[df['city'] == 'Hyderabad']['total_amount'].sum()
    n2_answer = round(hyderabad_rev)
else:
    n2_answer = "City column not found"
print(f"N2. {n2_answer}")

# N3: Distinct users who placed at least one order
n3_answer = df['user_id'].nunique()
print(f"N3. {n3_answer}")

# N4: Average order value for Gold members (rounded to 2 decimals)
n4_answer = round(gold_df['total_amount'].mean(), 2)
print(f"N4. {n4_answer}")

# N5: Orders from restaurants with rating \u2265 4.5
n5_answer = len(df[df['rating'] >= 4.5])
print(f"N5. {n5_answer}")

# N6: Orders in top revenue city among Gold members only
gold_city_rev = gold_df.groupby('city')['total_amount'].sum()
top_gold_city = gold_city_rev.idxmax()
orders_in_top_city = len(gold_df[gold_df['city'] == top_gold_city])
n6_answer = orders_in_top_city
print(f"N6. {n6_answer}")

print("\n" + "=" * 60)
print("SHREEKANTH ANSWERS")
print("=" * 60)

# Create a summary for easy copying
summary = f"""
MULTIPLE CHOICE:
1. {q1_answer}
2. {q2_answer}
3. {q3_answer}
4. {q4_answer}
5. {q5_answer}
6. {q6_answer}
7. {q7_answer}%
8. {q8_restaurant}
9. {q9_answer}
10. {q10_answer}

NUMERICAL:
1. {n1_answer}
2. {n2_answer}
3. {n3_answer}
4. {n4_answer}
5. {n5_answer}
6. {n6_answer}
"""

print(summary)

# Loading MY final dataset
import pandas as pd
df = pd.read_csv('final_food_delivery_dataset.csv')

print("=" * 60)
print("FILL-IN-THE-BLANK ANSWERS")
print("=" * 60)

# 1. Join column between orders.csv and users.json
print(f"1. user_id")

# 2. Format of cuisine and rating dataset
print(f"2. SQL")

# 3. Total rows in final dataset
total_rows = len(df)
print(f"3. {total_rows}")

# 4. Value for non-matching users
print(f"4. NaN")

# 5. Pandas function for combining datasets
print(f"5. merge()")

# 6. Source of membership column
print(f"6. users.json")

# 7. Join key for orders and restaurants
print(f"7. restaurant_id")

# 8. Column identifying food type
print(f"8. cuisine")

# 9. How many times user details appear
# Check a specific user with multiple orders
user_orders = df['user_id'].value_counts()
if len(user_orders) > 0:
    max_orders = user_orders.iloc[0]
    print(f"9. multiple (up to {max_orders} times for frequent users)")
else:
    print(f"9. multiple")



"""# New Section"""